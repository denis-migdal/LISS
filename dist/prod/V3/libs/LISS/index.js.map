{"version":3,"file":"libs/LISS/index.js","mappings":"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","sources":["webpack://LISS/webpack/runtime/async module","webpack://LISS/./V3/libs/LISS/index.ts","webpack://LISS/./V3/src/utils/encode.ts","webpack://LISS/./V3/src/ContentGenerators/AutoContentGenerator.ts","webpack://LISS/./V3/src/ContentGenerators/ContentGenerator.ts","webpack://LISS/./V3/src/LISSClasses/LISSSignal.ts","webpack://LISS/./V3/src/LISSClasses/LISSBase.ts","webpack://LISS/./V3/src/LISSClasses/LISSUpdate.ts","webpack://LISS/./V3/src/define/autoload.ts","webpack://LISS/./V3/src/define/define.ts","webpack://LISS/./V3/src/define/index.ts","webpack://LISS/./V3/src/define/isDefined.ts","webpack://LISS/./V3/src/define/whenDefined.ts","webpack://LISS/./V3/src/index.ts","webpack://LISS/./V3/src/utils/DOM/getPropertyInitialValue.ts","webpack://LISS/./V3/src/utils/DOM/isDOMContentLoaded.ts","webpack://LISS/./V3/src/utils/DOM/isPageLoaded.ts","webpack://LISS/./V3/src/utils/DOM/whenDOMContentLoaded.ts","webpack://LISS/./V3/src/utils/DOM/whenPageLoaded.ts","webpack://LISS/./V3/src/utils/network/fetchText.ts","webpack://LISS/./V3/src/utils/network/require.ts","webpack://LISS/./V3/src/utils/parsers/html.ts","webpack://LISS/./V3/src/utils/parsers/index.ts","webpack://LISS/./V3/src/utils/parsers/isTemplateString.ts","webpack://LISS/./V3/src/utils/parsers/style.ts","webpack://LISS/./V3/src/utils/parsers/template.ts","webpack://LISS/./V3/src/utils/tests/assertElement.ts","webpack://LISS/webpack/bootstrap","webpack://LISS/webpack/runtime/define property getters","webpack://LISS/webpack/runtime/hasOwnProperty shorthand","webpack://LISS/webpack/startup"],"sourcesContent":["var webpackQueues = typeof Symbol === \"function\" ? Symbol(\"webpack queues\") : \"__webpack_queues__\";\nvar webpackExports = typeof Symbol === \"function\" ? Symbol(\"webpack exports\") : \"__webpack_exports__\";\nvar webpackError = typeof Symbol === \"function\" ? Symbol(\"webpack error\") : \"__webpack_error__\";\nvar resolveQueue = (queue) => {\n\tif(queue && queue.d < 1) {\n\t\tqueue.d = 1;\n\t\tqueue.forEach((fn) => (fn.r--));\n\t\tqueue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));\n\t}\n}\nvar wrapDeps = (deps) => (deps.map((dep) => {\n\tif(dep !== null && typeof dep === \"object\") {\n\t\tif(dep[webpackQueues]) return dep;\n\t\tif(dep.then) {\n\t\t\tvar queue = [];\n\t\t\tqueue.d = 0;\n\t\t\tdep.then((r) => {\n\t\t\t\tobj[webpackExports] = r;\n\t\t\t\tresolveQueue(queue);\n\t\t\t}, (e) => {\n\t\t\t\tobj[webpackError] = e;\n\t\t\t\tresolveQueue(queue);\n\t\t\t});\n\t\t\tvar obj = {};\n\t\t\tobj[webpackQueues] = (fn) => (fn(queue));\n\t\t\treturn obj;\n\t\t}\n\t}\n\tvar ret = {};\n\tret[webpackQueues] = x => {};\n\tret[webpackExports] = dep;\n\treturn ret;\n}));\n__webpack_require__.a = (module, body, hasAwait) => {\n\tvar queue;\n\thasAwait && ((queue = []).d = -1);\n\tvar depQueues = new Set();\n\tvar exports = module.exports;\n\tvar currentDeps;\n\tvar outerResolve;\n\tvar reject;\n\tvar promise = new Promise((resolve, rej) => {\n\t\treject = rej;\n\t\touterResolve = resolve;\n\t});\n\tpromise[webpackExports] = exports;\n\tpromise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise[\"catch\"](x => {}));\n\tmodule.exports = promise;\n\tbody((deps) => {\n\t\tcurrentDeps = wrapDeps(deps);\n\t\tvar fn;\n\t\tvar getResult = () => (currentDeps.map((d) => {\n\t\t\tif(d[webpackError]) throw d[webpackError];\n\t\t\treturn d[webpackExports];\n\t\t}))\n\t\tvar promise = new Promise((resolve) => {\n\t\t\tfn = () => (resolve(getResult));\n\t\t\tfn.r = 0;\n\t\t\tvar fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));\n\t\t\tcurrentDeps.map((dep) => (dep[webpackQueues](fnQueue)));\n\t\t});\n\t\treturn fn.r ? promise : getResult();\n\t}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));\n\tqueue && queue.d < 0 && (queue.d = 0);\n};","import LISS from \"@LISS/src/LISS\";\n\nimport \"@LISS/src/define\";\nimport \"@LISS/src/define/autoload\";\n\nimport \"@LISS/src/utils/parsers\";\nimport \"@LISS/src/utils/network/require\";\n\nimport \"@LISS/src/utils/tests/assertElement\";\n\ndeclare module \"@LISS/src/LISS\" {\n    interface ILISS {\n        VERSION: string\n    }\n}\n\nLISS.VERSION = \"V3\";\n\nexport default LISS;\n\n// @ts-ignore\nglobalThis.LISS = LISS;","const converter = document.createElement('span');\n\nexport default function encodeHTML(text: string) {\n\tconverter.textContent = text;\n\treturn converter.innerHTML;\n}","import { HTML } from \"@LISS/src/utils/parsers/template\";\nimport ContentGenerator from \"./ContentGenerator\";\nimport encodeHTML from \"@LISS/src/utils/encode\";\n\nconst regex = /\\$\\{(.+?)\\}/g;\n\nexport default class AutoContentGenerator extends ContentGenerator {\n\n    protected override prepareTemplate(html: HTML) {\n        \n        this.data = null;\n\n        if( typeof html === 'string' ) {\n            this.data = html;\n            return;\n            /*\n            html = html.replaceAll(/\\$\\{([\\w]+)\\}/g, (_, name: string) => {\n                return `<liss value=\"${name}\"></liss>`;\n            });*/\n\n            //TODO: ${} in attr\n                // - detect start ${ + end }\n                // - register elem + attr name\n                // - replace. \n        }\n        \n        super.prepareTemplate(html);\n    }\n\n    override fillContent(shadow: ShadowRoot) {\n        \n        // https://stackoverflow.com/questions/29182244/convert-a-string-to-a-template-string\n        if( this.data !== null) {\n            const str = (this.data as string).replace(regex, (_, match) => {\n                const value = shadow.host.getAttribute(match);\n                if( value === null)\n                    return ''; \n                return encodeHTML(value);\n            });\n\n            super.prepareTemplate(str);\n        }\n\n        super.fillContent(shadow);\n\n        /*\n        // html magic values could be optimized...\n        const values = content.querySelectorAll('liss[value]');\n        for(let value of values)\n            value.textContent = host.getAttribute(value.getAttribute('value')!)\n        */\n    }\n}","import { isRessourceReady, Ressource, waitRessource } from \"@LISS/src/utils/network/ressource\";\nimport template, { HTML }   from \"@LISS/src/utils/parsers/template\";\nimport style   , {CSS}      from \"@LISS/src/utils/parsers/style\";\nimport isDOMContentLoaded   from \"@LISS/src/utils/DOM/isDOMContentLoaded\";\nimport whenDOMContentLoaded from \"@LISS/src/utils/DOM/whenDOMContentLoaded\";\n\ntype STYLE = CSS | CSS[];\n\nexport type ContentGenerator_Opts = {\n    html   ?: Ressource<HTML>,\n    css    ?: Ressource<STYLE>\n}\n\nconst sharedCSS = new CSSStyleSheet();\n//const sharedCSS = getSharedCSS(); // from LISSHost...\n\nexport default class ContentGenerator {\n\n    protected data: any;\n\n    constructor({\n        html,\n        css    = [],\n    }: ContentGenerator_Opts = {}) {\n\n        const isReady = isRessourceReady<HTML> (html)\n                     && isRessourceReady<STYLE>(css)\n                     && isDOMContentLoaded();\n\n        if( isReady )\n            this.prepare(html, css);\n\n        const whenReady: Promise<[HTML|undefined, STYLE|undefined, unknown]> = Promise.all([\n            waitRessource<HTML |undefined>(html),\n            waitRessource<STYLE|undefined>(css),\n            whenDOMContentLoaded()\n        ]);\n\n        whenReady.then( (args) => this.prepare(args[0], args[1]) );\n\n        this.isReady   = isReady;\n        this.whenReady = whenReady;\n    }\n\n    /** ready ***/\n\n    readonly whenReady: Promise<unknown>;\n    readonly isReady  : boolean = false;\n\n    /** process ressources **/\n\n    protected stylesheets: CSSStyleSheet[]       = [];\n    protected template   : DocumentFragment|null = null;\n\n    protected prepare(html: HTML|undefined, css: STYLE|undefined) {\n        if( html !== undefined )\n            this.prepareTemplate(html);\n        if( css  !== undefined )\n            this.prepareStyle   (css);\n    }\n\n    protected prepareTemplate(html: HTML) {\n        this.template = template(html);\n    }\n    protected prepareStyle(css: STYLE) {\n\n        if( ! Array.isArray(css) )\n            css = [css];\n\n        this.stylesheets = css.map(e => style(e) );\n    }\n\n    /*** Generate contents ***/\n\n    initContent(target: HTMLElement, mode:\"open\"|\"closed\"|null) {\n\n        let content: ShadowRoot|HTMLElement = target;\n        if( mode !== null) {\n            content = target.attachShadow({mode});\n            content.adoptedStyleSheets.push(sharedCSS, ...this.stylesheets);\n        }\n        //TODO: CSS for no shadow ???\n        \n        this.fillContent(content);\n\n        return content;\n    }\n\n    fillContent(target: ShadowRoot|HTMLElement|DocumentFragment) {\n        \n        if( this.template !== null)\n            target.replaceChildren( this.createContent() );\n\n        //TODO...\n        customElements.upgrade(target);\n    }\n\n    createContent() {\n        return this.template!.cloneNode(true);\n    }\n}","import { Signal } from \"@LISS/src/signals/Signal\";\nimport ROSignal   from \"@LISS/src/signals/ROSignal\";\nimport LISSUpdate from \"./LISSUpdate\";\nimport getPropertyInitialValue from \"@LISS/src/utils/DOM/getPropertyInitialValue\";\n\n//TODO: getter ?\n\nexport default class LISSSignal<T> extends LISSUpdate {\n\n    #signal = new Signal<T>();\n\n    #callback = () => this.requestUpdate();\n\n    constructor(value: null|T = null, signal: null|ROSignal<T> = null) {\n        super();\n\n        value  ??= getPropertyInitialValue(this, \"value\" , null);\n        signal ??= getPropertyInitialValue(this, \"source\", null)\n\n        if( value  !== null)\n            this.#signal.value = value;\n        if( signal !== null)\n            this.#signal.source = signal;\n\n        this.#signal.listen( this.#callback );\n    }\n\n    set source(source: ROSignal<T>|null) {\n        this.#signal.source = source;\n    }\n    set value(value: T|null) {\n        this.#signal.value = value;\n    }\n\n}","import ContentGenerator from \"@LISS/src/ContentGenerators/ContentGenerator\";\n\nexport default class LISSBase extends HTMLElement {\n\n    static readonly SHADOW_MODE      : \"open\"|\"closed\"|null = null;\n    // TODO: static cache getter + use static HTML/CSS.\n    static readonly CONTENT_GENERATOR: ContentGenerator|null = null;\n\n    readonly content  : ShadowRoot|HTMLElement        = this;\n    readonly host     : HTMLElement                   = this;\n    readonly controler: Omit<this, keyof HTMLElement> = this;\n\n    constructor() {\n        super();\n\n        const klass = this.constructor as typeof LISSBase;\n\n        if( klass.CONTENT_GENERATOR !== null )\n            this.content = klass.CONTENT_GENERATOR.initContent(this, klass.SHADOW_MODE);\n    }\n\n\n    // define for auto-complete.\n    static observedAttributes: string[] = [];\n    attributeChangedCallback(name: string, oldval: string|null, newval: string|null){}\n}","import LISSBase from \"./LISSBase\";\n\nexport default class LISSUpdate extends LISSBase {\n\n    constructor() {\n        super();\n\n        observer.observe(this);\n    }\n\n    #requestID: null|number = null;\n    #updateRequested = false;\n    #isVisible       = false;\n\n    static processIntersectionObserver(entries: IntersectionObserverEntry[]) {\n\n        for(let i = 0; i < entries.length; ++i) {\n\n            const target     = entries[i].target as LISSUpdate;\n            const isVisible  = entries[i].isIntersecting;\n\n            target.#isVisible = isVisible;\n\n            if( ! isVisible && target.#requestID !== null)\n                cancelAnimationFrame(target.#requestID);\n\n            if( isVisible && target.#updateRequested && target.#requestID === null )\n                target.#scheduleUpdate();\n        }\n    }\n\n    #scheduleUpdate() {\n        this.#requestID = requestAnimationFrame( () => {\n            this.#requestID       = null;\n            this.#updateRequested = false;\n            this.onUpdate();\n        });\n    }\n\n    requestUpdate() {\n\n        if( this.#updateRequested )\n            return;\n\n        this.#updateRequested = true;\n\n        if( ! this.#isVisible )\n            return;\n\n        this.#scheduleUpdate();\n    }\n\n    protected onUpdate() {\n\n    }\n}\n\nconst observer = new IntersectionObserver( LISSUpdate.processIntersectionObserver );","import define, { WaitingDefine } from \"@LISS/src/define/define\";\nimport LISS from \"@LISS/src\";\nimport AutoContentGenerator from \"@LISS/src/ContentGenerators/AutoContentGenerator\";\nimport isPageLoaded   from \"@LISS/src/utils/DOM/isPageLoaded\";\nimport whenPageLoaded from \"@LISS/src/utils/DOM/whenPageLoaded\";\nimport fetchText      from \"@LISS/src/utils/network/fetchText\";\nimport execute        from \"@LISS/src/utils/execute\";\n\nconst script =  document.querySelector<HTMLElement>('script:is([liss-auto],[liss-cdir],[liss-sw])');\n\nexport const LISS_MODE    = script?.getAttribute('liss-mode') ?? null;\nexport const DEFAULT_CDIR = script?.getAttribute('liss-cdir') ?? null;\n\n// TODO: default ?\nconst SW_PATH             = script?.getAttribute('liss-sw') ?? null;\n\nif(LISS_MODE === \"auto-load\" && DEFAULT_CDIR !== null) {\n    if( ! isPageLoaded() )\n        await whenPageLoaded();\n    autoload(DEFAULT_CDIR);\n}\n\nexport function autoload(cdir: string) {\n\n    const SW: Promise<void> = new Promise( async (resolve) => {\n\n        if( SW_PATH === null || SW_PATH === \"\") {\n            //console.warn(\"You are using LISS Auto mode without sw.js.\");\n            return resolve();\n        }\n        \n        try {\n            await navigator.serviceWorker.register(SW_PATH, {scope: \"/V3/assets/\"});\n        } catch(e) {\n            console.warn(\"Registration of ServiceWorker failed\");\n            console.error(e);\n            return resolve();\n        }\n\n        if( navigator.serviceWorker.controller )\n            return resolve();\n\n        navigator.serviceWorker.addEventListener('controllerchange', () => {\n            resolve();\n        });\n    });\n\n    if( cdir[cdir.length-1] !== '/')\n        cdir += '/';\n\n    //const brython = script.getAttribute(\"brython\");\n\n    // observe for new injected tags.\n    new MutationObserver( (mutations) => {\n        for(let mutation of mutations)\n            for(let addition of mutation.addedNodes)\n                if( addition.constructor.name === \"HTMLElement\" )\n                // cf https://github.com/WICG/webcomponents/issues/1097#issuecomment-2665092315\n                // if(addition instanceof HTMLUnknownElement)\n                    addTag(addition as HTMLElement)\n\n    }).observe( document, { childList:true, subtree:true });\n\n    for( let elem of document.querySelectorAll<HTMLElement>(\":not(:defined)\") )\n        addTag( elem );\n\n    async function addTag(tag: HTMLElement) {\n\n        await SW; // ensure SW is installed.\n\n        const tagname = tag.tagName.toLowerCase();\n\n        if(  WaitingDefine.has(tagname)\n            // could be defined, but not yet upgraded\n         || customElements.get(tagname) !== undefined)\n            return;\n\n        loadComponent(tagname, {\n            //brython,\n            cdir\n        });\t\t\n    }\n}\n\n/*****/\n\ntype loadComponent_Opts = {\n\tcdir   ?: string|null\n};\n\ntype Cstr<T> = (...args: any[]) => T;\n\nexport async function loadComponent<T extends HTMLElement = HTMLElement>(\n\ttagname: string,\n\t{\n\t\tcdir    = DEFAULT_CDIR,\n\t\t// brython = null\n\t}: loadComponent_Opts = {}\n): Promise<Cstr<T>> {\n\n\tWaitingDefine.add(tagname);\n\n    let true_tagdir = globalThis.LISSContext?.override_tags?.[tagname] ?? tagname;     \n\n\tconst compo_dir = `${cdir}${true_tagdir}/`;\n\n\tconst files: Record<string,string|undefined> = {};\n\n\t// strats : JS -> Bry -> HTML+CSS (cf script attr).\n\n    files[\"js\"] = await fetchText(`${compo_dir}index.js`, true);\n\n    if( files[\"js\"] === undefined) {\n        // try/catch ?\n        const promises = [\n            fetchText(`${compo_dir}index.html`, true)!,\n            fetchText(`${compo_dir}index.css` , true)!\n        ];\n\n        [files[\"html\"], files[\"css\" ]] = await Promise.all(promises);\n    }\n\n\treturn await defineWebComponent(tagname, files, compo_dir);\n}\n\n//TODO: rename from files ?\nasync function defineWebComponent(tagname: string,\n                                  files: Record<string, any>,\n                                  origin : string,\n                                ) {\n    \n    let klass;\n    if( \"js\" in files )\n        klass = (await execute<any>(files[\"js\"], \"js\", origin)).default;\n\n    if( klass === undefined )\n        klass = LISS({\n            content_generator: AutoContentGenerator,\n            ...files\n        });\n\n    define(tagname, klass);\n\n    return klass;\n}","import ContentGenerator from \"@LISS/src/ContentGenerators/ContentGenerator\";\nimport { _whenDefinedPromises } from \"./whenDefined\";\n\nexport const WaitingDefine = new Set<string>();\n\nexport default async function define(tagname: string, Klass: new(...args:any[]) => HTMLElement) {\n\n    //TODO: Python class...\n\n    //TODO: type safe\n    if( \"CONTENT_GENERATOR\" in Klass ) {\n        const generator = Klass.CONTENT_GENERATOR as ContentGenerator;\n\n        if( ! generator.isReady ) {\n            WaitingDefine.add(tagname);\n            await generator.whenReady;\n        }\n    }\n\n    WaitingDefine.delete(tagname);\n    customElements.define(tagname, Klass);\n\n    const p = _whenDefinedPromises.get(Klass);\n    if( p !== undefined )\n        p.resolve();\n}\n\nimport LISS from \"@LISS/src/LISS\";\n\ndeclare module \"@LISS/src/LISS\" {\n    interface ILISS {\n        define: typeof define;\n    }\n}\n\nLISS.define = define;","import define      from \"./define\";\nimport isDefined   from \"./isDefined\";\nimport whenDefined from \"./whenDefined\";\n\nimport LISS from \"@LISS/src/LISS\";\n\ndeclare module \"@LISS/src/LISS\" {\n    interface ILISS {\n        define    : typeof define;\n        isDefined: typeof isDefined;\n        whenDefined   : typeof whenDefined;\n    }\n}\n\nLISS.define      = define;\nLISS.isDefined   = isDefined;\nLISS.whenDefined = whenDefined;\n\nexport {define, isDefined, whenDefined};","export default function isDefined(elem: string|(new(...args:any[])=>HTMLElement)): boolean {\n    \n    if( typeof elem === \"string\")\n        return customElements.get(elem) !== undefined;\n\n    return customElements.getName(elem) !== null;\n}","type Cstr<T> = new(...args:any[])=> T;\n\nexport const _whenDefinedPromises = new WeakMap<Cstr<HTMLElement>, PromiseWithResolvers<void>>();\n\nexport default async function whenDefined<T extends HTMLElement>(elem: string|Cstr<T>): Promise<Cstr<T>> {\n    \n    if( typeof elem === \"string\")\n        return await customElements.whenDefined(elem) as Cstr<T>;\n\n    if( customElements.getName(elem) !== null)\n        return elem as Cstr<T>;\n\n    let p = _whenDefinedPromises.get(elem);\n    if( p === undefined ){\n        p = Promise.withResolvers<void>();\n        _whenDefinedPromises.set(elem, p);\n    }\n\n    await p.promise;\n    return elem;\n}","import LISS from \"@LISS/src/LISS\";\n\nimport \"@LISS/src/define\";\nimport \"@LISS/src/define/autoload\";\n\nimport \"@LISS/src/utils/parsers\";\nimport \"@LISS/src/utils/network/require\";\n\nimport \"@LISS/src/utils/tests/assertElement\";\n\ndeclare module \"@LISS/src/LISS\" {\n    interface ILISS {\n        VERSION: string\n    }\n}\n\nLISS.VERSION = \"V3\";\n\nexport default LISS;\n\n// @ts-ignore\nglobalThis.LISS = LISS;","export default function getPropertyInitialValue<E extends HTMLElement,\n                                                N extends keyof E,\n                                                D = undefined>\n                                (e: E, name: N, defaultValue?: D): D|E[N] {\n\n    if( ! Object.hasOwn(e, name) )\n        return defaultValue as D;\n\n    const  _ = e[name];\n    delete     e[name];\n    return _;\n}","export default function isDOMContentLoaded() {\n    return document.readyState === \"interactive\" || document.readyState === \"complete\";\n}","export default function isPageLoaded() {\n    return document.readyState === \"complete\"\n}","import isDOMContentLoaded from \"./isDOMContentLoaded\";\n\nexport default async function whenDOMContentLoaded() {\n    if( isDOMContentLoaded() )\n        return;\n\n    const {promise, resolve} = Promise.withResolvers<void>()\n\n\tdocument.addEventListener('DOMContentLoaded', () => {\n\t\tresolve();\n\t}, true);\n\n    await promise;\n}","import isPageLoaded from \"./isPageLoaded\";\n\nexport default async function whenDOMContentLoaded() {\n    if( isPageLoaded() )\n        return;\n\n    const {promise, resolve} = Promise.withResolvers<void>()\n\n\tdocument.addEventListener('load', resolve as any, true);\n\n    await promise;\n}","// in auto-mode use ServiceWorker to hide 404 error messages.\n// if playground files, use them.\nexport default async function fetchText(uri: string|URL, hide404: boolean = false) {\n\n    const fetchContext = globalThis.LISSContext?.fetch;\n    if( fetchContext !== undefined ) { // for the playground\n        const path = new URL(uri, fetchContext.cwd );\n        const value = fetchContext.files[path.toString()];\n\n        if( value === \"\" )\n            return undefined;\n        if( value !== undefined)\n            return value;\n    }\n\n    const options = hide404\n                        ? {headers:{\n                            \"liss-auto\": \"true\", //TODO: remove\n                            \"hide-404\" : \"true\"\n                        }}\n                        : {};\n\n    const response = await fetch(uri, options);\n    if(response.status !== 200 )\n        return undefined;\n\n    if( hide404 && response.headers.get(\"status\")! === \"404\" )\n        return undefined;\n\n    const answer = await response.text();\n\n    if(answer === \"\")\n        return undefined;\n\n    return answer\n}\n\n\n\ndeclare global {\n\n    interface LISSContext {\n        fetch?: {\n            cwd  : string,\n            files: Record<string, string>\n        }\n    }\n\n    var LISSContext: LISSContext;\n}","import fetchText from \"./fetchText\";\n\n// @ts-ignore\nglobalThis.require = async function(url: string) {\n\n    const stack = new Error().stack!;\n\n    let caller: string;\n    if( stack.startsWith(\"Error\") ) {   // Chrome ?\n        caller = stack.split('\\n')[1+1].slice(7);\n    } else {                            // FF ?\n        caller = stack.split('\\n')[1].slice(1);\n    }\n\n    if( caller.startsWith('blob:') ) {\n\n        caller = caller.slice(caller.lastIndexOf('/') + 1 );\n        caller = caller.slice(0, caller.indexOf(':'));\n\n        url = LISSContext.execute!.url_map[caller] + url;\n        \n        //TODO: rewrite URL...\n    } else {\n        console.warn( caller );\n        throw new Error(\"require from non-blob import, unimplemented\");\n    }\n\n    // TODO: reverify playground\n\n    return await fetchText(url);\n}","import isTemplateString from \"./isTemplateString\";\nimport { Template } from \"./types\";\n\nconst template = document.createElement(\"template\");\nconst df = template.content;\n\nexport default function html<T extends HTMLElement>(...raw: Template<string>): T {\n    \n    let elem: string = raw[0] as any;\n\n    if( isTemplateString(raw) ) {\n        \n        const str = raw[0];\n\n        let string = str[0];\n        for(let i = 1; i < raw.length; ++i) {\n            string += raw[i];\n            string += str[i];\n        }\n\n        elem = string;\n    }\n\n    template.innerHTML = elem;\n\n    if( df.childNodes.length !== 1)\n        throw new Error(\"Error\");\n\n    return df.firstChild as T;\n}","import LISS from \"@LISS/src/LISS\";\n\nimport html     from \"./html\"\nimport template from \"./template\";\nimport style    from \"./style\";\n\ndeclare module \"@LISS/src/LISS\" {\n    interface ILISS {\n        html    : typeof html;\n        template: typeof template;\n        style   : typeof style;\n    }\n}\n\nLISS.style    = style;\nLISS.template = template;\nLISS.html     = html;\n\nexport {style, template, html};","export default function isTemplateString(raw: [unknown, ...unknown[]]): raw is [TemplateStringsArray, ...string[]] {\n    return Array.isArray(raw[0]);\n}","import { Template } from \"./types\";\n\nexport type CSS   = string|CSSStyleSheet|HTMLStyleElement;\n\nexport default function style(...raw: Template<CSS>): CSSStyleSheet {\n\n    let elem = raw[0];\n\n    if( elem instanceof CSSStyleSheet )\n        return elem;\n    if( elem instanceof HTMLStyleElement)\n        return elem.sheet!;\n\n    if( Array.isArray(elem) ) {\n        \n        const str = raw[0] as TemplateStringsArray;\n\n        let string = str[0];\n        for(let i = 1; i < raw.length; ++i) {\n            string += raw[i];\n            string += str[i];\n        }\n\n        elem = string;\n    }\n\n    if( typeof elem !== \"string\") {\n        console.warn(elem);\n        console.trace();\n        throw new Error(\"Should not occurs\");\n    }\n\n    const style = new CSSStyleSheet();\n    style.replaceSync(elem);\n    return style;\n}","import isTemplateString from \"./isTemplateString\";\nimport { Template } from \"./types\";\n\nexport type HTML  = DocumentFragment|HTMLElement|string;\n\nexport default function template( ...raw:Template<HTML>): DocumentFragment {\n\n    let elem: HTML = raw[0] as any;\n\n    if( isTemplateString(raw) ) {\n        \n        const str = raw[0];\n\n        let string = str[0];\n        for(let i = 1; i < raw.length; ++i) {\n            string += raw[i];\n            string += str[i];\n        }\n\n        elem = string;\n    }\n\n    if( elem instanceof DocumentFragment )\n        return elem.cloneNode(true) as DocumentFragment;\n\n    // must use template as DocumentFragment doesn't have .innerHTML\n    let template = document.createElement('template');\n\n    if(typeof elem === 'string')\n        template.innerHTML = elem.trim();\n    else {\n        if( elem instanceof HTMLElement)\n            // prevents issue if elem is latter updated.\n            elem = elem.cloneNode(true) as HTMLElement;\n        \n        template.append( elem );\n    }\n\n    //if( template.content.childNodes.length === 1 && template.content.firstChild!.nodeType !== Node.TEXT_NODE)\n    //  return template.content.firstChild! as unknown as T;\n    \n    return template.content!;\n}","import whenDefined from \"@LISS/src/define/whenDefined\";\n\ntype Options = {\n    shadow_html?: string,\n    css        ?: Record<string, Record<string, string>>\n}\n\nfunction waitFrame() {\n    const { promise, resolve} = Promise.withResolvers<void>();\n\n    requestAnimationFrame( () => resolve() );\n\n    return promise;\n}\n\nexport default async function assertElement(tagname: string, opts: Options = {}) {\n    \n    const shadow_html = opts.shadow_html ?? null;\n    const css         = opts.css         ?? {};\n\n\n    await whenDefined(tagname);\n\n    //for(let i = 0; i < 1; ++i)\n    //    await waitFrame();\n\n    const elem = document.querySelector(tagname);\n\n    if( elem === null )\n        throw new Error(\"Component not found\");\n\n    //TODO: await LISS.whenInitialized(elem); ?\n\n    if( elem.tagName.toLowerCase() !== tagname )\n        throw new Error(\n`Wrong tagname.\nExpected: ${tagname}\nGot: ${elem.tagName.toLowerCase()}`);\n\n    if( elem.constructor.name === \"HTMLElement\")\n        throw new Error(`Element not upgraded!`);\n\n    if( shadow_html !== elem.shadowRoot ) {\n        if( shadow_html === null || elem.shadowRoot === null )\n            throw new Error(`ShadowRoot missing or unexpected.`);\n        if( shadow_html !== elem.shadowRoot.innerHTML )\n            throw new Error(\n`HTML content mismatched.\nExpected: ${shadow_html}\nGot: ${elem.shadowRoot.innerHTML}`);\n    }\n\n    for(let selector in css ) {\n        const expected = css[selector];\n\n        let sub_elems: NodeListOf<HTMLElement>|HTMLElement[];\n        if( selector === \"\")\n            sub_elems = [elem as HTMLElement];\n        else\n            sub_elems = (((elem as any).content ?? elem.shadowRoot ?? elem) as ShadowRoot|HTMLElement).querySelectorAll<HTMLElement>(selector);\n    \n        if( sub_elems.length === 0)\n            throw new Error(`Elements \"${selector}\" not found`);\n\n        for( let sub_elem of sub_elems ) {\n\n            // compare style : https://stackoverflow.com/questions/59342928/getcomputedstyle-only-the-changes-from-default\n            //  ^ get all elements, find matching qs, compare\n            // pseudo class  : https://stackoverflow.com/questions/32091848/template-queryselector-using-scope-pseudo-class-works-with-document-but-not\n\n            const css = getComputedStyle(sub_elem)\n            for(let propname in expected) {\n                const val = css.getPropertyValue(propname);\n                if( val !== expected[propname] ) {\n                        throw new Error(\n        `CSS mismatch\n        Expected:${expected}\n        Got: ${css}`);\n                }\n            }\n        }\n    }\n}\n\nimport LISS from \"@LISS/src/LISS\";\n\ndeclare module \"@LISS/src/LISS\" {\n    interface ILISS {\n        assertElement    : typeof assertElement;\n    }\n}\n\nLISS.assertElement = assertElement;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// startup\n// Load entry module and return exports\n// This entry module used 'module' so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(7068);\n"],"names":["webpackQueues","webpackExports","webpackError","resolveQueue","LISS","VERSION","globalThis","document","createElement","ContentGenerator","CSSStyleSheet","LISSUpdate","LISSBase","HTMLElement","static","content","this","host","controler","constructor","super","klass","CONTENT_GENERATOR","initContent","SHADOW_MODE","attributeChangedCallback","name","oldval","newval","observer","IntersectionObserver","observe","processIntersectionObserver","entries","i","length","target","isVisible","isIntersecting","cancelAnimationFrame","requestAnimationFrame","onUpdate","requestUpdate","script","querySelector","LISS_MODE","getAttribute","DEFAULT_CDIR","SW_PATH","autoload","cdir","SW","Promise","async","resolve","navigator","serviceWorker","register","scope","e","console","warn","error","controller","addEventListener","MutationObserver","mutations","mutation","addition","addedNodes","addTag","childList","subtree","elem","querySelectorAll","tag","tagname","tagName","toLowerCase","WaitingDefine","has","undefined","customElements","get","loadComponent","add","compo_dir","LISSContext","override_tags","files","fetchText","promises","all","defineWebComponent","origin","execute","default","content_generator","AutoContentGenerator","define","isPageLoaded","whenPageLoaded","Set","Klass","generator","isReady","whenReady","delete","p","_whenDefinedPromises","isDefined","getName","whenDefined","WeakMap","withResolvers","set","promise","getPropertyInitialValue","defaultValue","Object","hasOwn","_","isDOMContentLoaded","readyState","whenDOMContentLoaded","uri","hide404","fetchContext","fetch","path","URL","cwd","value","toString","options","headers","response","status","answer","text","require","url","stack","Error","caller","startsWith","split","slice","lastIndexOf","indexOf","url_map","template","df","html","raw","isTemplateString","str","string","innerHTML","childNodes","firstChild","style","Array","isArray","HTMLStyleElement","sheet","trace","replaceSync","DocumentFragment","cloneNode","trim","append","assertElement","opts","shadow_html","css","shadowRoot","selector","expected","sub_elems","sub_elem","getComputedStyle","propname","getPropertyValue","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","Symbol","queue","d","forEach","fn","r","a","body","hasAwait","currentDeps","outerResolve","reject","depQueues","rej","x","deps","map","dep","then","obj","ret","wrapDeps","getResult","fnQueue","q","push","err","definition","key","o","defineProperty","enumerable","prop","prototype","hasOwnProperty","call","__webpack_exports__"],"sourceRoot":""}